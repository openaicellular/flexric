/* 
 * Handling messages in E2 interface that have to communicate to SM block
 * It has to expose read() functionality for handling of subscription procedure and write() one 
 * for the handling of CTRL/INSERT/UPDATE procedures. 
 */
#ifndef E2_SM_AGENT_H
#define E2_SM_AGENT_H 

#include "agent/e2_agent_api.h"
#include "lib/ind_event.h"
#include "lib/ap/e2ap_types/common/e2ap_global_node_id.h"
#include "sm/kpm_sm_v03.00/kpm_sm_id.h"
#include "sm/mac_sm/mac_sm_id.h"

/* type of messages generated by RAN interface and with destination the E2 interface or RAN interface*/
typedef enum {
      RAN_E2_NONE = 0, // means that no message has to be sent anywhere
      RAN_E2_CONFIG_FWD,
      RAN_E2_CTRL_FWD,
      ASK_RAN_SETUP,
      ASK_RAN_INDICATION,
      ASK_RAN_CTRL
} ran_e2_type_id_t;

typedef struct ran_e2_setup_t {
  const char *p; 
} ran_e2_setup_t;

typedef struct ran_e2_config_t {
  global_e2_node_id_t global_e2_node_id;
} ran_e2_config_t;

typedef struct ctrl_ev_reply_t {
  int             sm_id;      
  sm_ag_if_ans_t  ans;
} ctrl_ev_reply_t;

typedef struct ctrl_ev_t {
  int           sm_id;      
  ric_gen_id_t  ric_id; // XX: proably too be removed as we do not use anymore this mechansim of correlation data passing
  sm_ag_if_wr_t req;
} ctrl_ev_t;
/* 
 * next_msg_t is a container for the next message to be sent in the state machine of I/O module for RAN. 
 * The next message can be in the direction of RAN endpoint or E2 endpoint
 */
typedef struct next_msg_t {
  ran_e2_type_id_t  type_id;
  union{  
    ind_event_t     ran_sub_msg;
    ran_e2_config_t config_msg;
    ran_e2_setup_t  e2setup_msg;
    ctrl_ev_reply_t ctrl_msg;
  };
} next_msg_t;

static inline bool next_msg_is(next_msg_t msg, ran_e2_type_id_t val) { return msg.type_id == val; }

sm_io_ag_ran_t init_io_proxy_ag();

bool is_sm_whitelisted(int sm_id);

#endif