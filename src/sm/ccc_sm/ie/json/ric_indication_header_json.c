/**
 * stdout
 * This file has been autogenerated using quicktype https://github.com/quicktype/quicktype - DO NOT EDIT
 * This file depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable
 * To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);
 * To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);
 * To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);
 * To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);
 * To delete json data use the following: cJSON_Delete<type>(<data>);
 */

#ifndef __STDOUT__
#define __STDOUT__

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include <assert.h>

#include "ric_indication_header_json.h"

#ifndef cJSON_Bool
#define cJSON_Bool (cJSON_True | cJSON_False)
#endif
#ifndef cJSON_Map
#define cJSON_Map (1 << 16)
#endif
#ifndef cJSON_Enum
#define cJSON_Enum (1 << 17)
#endif

indication_reason_e cJSON_Getindication_reasonValue(const cJSON * j) {
  indication_reason_e x = 0;
  if (NULL != j) {
    if (!strcmp(cJSON_GetStringValue(j), "periodic")) x = IND_REASON_PERIODIC;
    else if (!strcmp(cJSON_GetStringValue(j), "uponChange")) x = IND_REASON_UPON_CHANGE;
    else if (!strcmp(cJSON_GetStringValue(j), "uponSubscription")) x = IND_REASON_UPON_SUB;
  }
  return x;
}

cJSON * cJSON_Createindication_reason(const indication_reason_e x) {
  cJSON * j = NULL;
  switch (x) {
    case IND_REASON_PERIODIC: j = cJSON_CreateString("periodic"); break;
    case IND_REASON_UPON_CHANGE: j = cJSON_CreateString("uponChange"); break;
    case IND_REASON_UPON_SUB: j = cJSON_CreateString("uponSubscription"); break;
    default:
      assert(0 != 0 && "Unknown indication reason");
  }
  return j;
}

indication_header_format_json_t * cJSON_Parseindication_header_format(const char * s) {
  indication_header_format_json_t * x = NULL;
  if (NULL != s) {
    cJSON * j = cJSON_Parse(s);
    if (NULL != j) {
      x = cJSON_Getindication_header_formatValue(j);
      cJSON_Delete(j);
    }
  }
  return x;
}

indication_header_format_json_t * cJSON_Getindication_header_formatValue(const cJSON * j) {
  indication_header_format_json_t * x = NULL;
  if (NULL != j) {
    if (NULL != (x = cJSON_malloc(sizeof(indication_header_format_json_t)))) {
      memset(x, 0, sizeof(indication_header_format_json_t));
      if (cJSON_HasObjectItem(j, "eventTime")) {
        x->event_time = strdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "eventTime")));
      }
      else {
        if (NULL != (x->event_time = cJSON_malloc(sizeof(char)))) {
          x->event_time[0] = '\0';
        }
      }
      if (cJSON_HasObjectItem(j, "indicationReason")) {
        x->indication_reason = cJSON_Getindication_reasonValue(cJSON_GetObjectItemCaseSensitive(j, "indicationReason"));
      }
    }
  }
  return x;
}

cJSON * cJSON_Createindication_header_format(const indication_header_format_json_t * x) {
  cJSON * j = NULL;
  if (NULL != x) {
    if (NULL != (j = cJSON_CreateObject())) {
      if (NULL != x->event_time) {
        cJSON_AddStringToObject(j, "eventTime", x->event_time);
      }
      else {
        cJSON_AddStringToObject(j, "eventTime", "");
      }
      cJSON_AddItemToObject(j, "indicationReason", cJSON_Createindication_reason(x->indication_reason));
    }
  }
  return j;
}

char * cJSON_Printindication_header_format(const indication_header_format_json_t * x) {
  char * s = NULL;
  if (NULL != x) {
    cJSON * j = cJSON_Createindication_header_format(x);
    if (NULL != j) {
      s = cJSON_Print(j);
      cJSON_Delete(j);
    }
  }
  return s;
}

void cJSON_Deleteindication_header_format(indication_header_format_json_t * x) {
  if (NULL != x) {
    if (NULL != x->event_time) {
      cJSON_free(x->event_time);
    }
    cJSON_free(x);
  }
}

ric_indication_header_json_t * cJSON_Parseric_indication_header(const char * s) {
  ric_indication_header_json_t * x = NULL;
  if (NULL != s) {
    cJSON * j = cJSON_Parse(s);
    if (NULL != j) {
      x = cJSON_Getric_indication_headerValue(j);
      cJSON_Delete(j);
    }
  }
  return x;
}

ric_indication_header_json_t * cJSON_Getric_indication_headerValue(const cJSON * j) {
  ric_indication_header_json_t * x = NULL;
  if (NULL != j) {
    if (NULL != (x = cJSON_malloc(sizeof(ric_indication_header_json_t)))) {
      memset(x, 0, sizeof(ric_indication_header_json_t));
      if (cJSON_HasObjectItem(j, "indicationHeaderFormat")) {
        x->indication_header_format = cJSON_Getindication_header_formatValue(cJSON_GetObjectItemCaseSensitive(j, "indicationHeaderFormat"));
      }
    }
  }
  return x;
}

cJSON * cJSON_Createric_indication_header(const ric_indication_header_json_t * x) {
  cJSON * j = NULL;
  if (NULL != x) {
    if (NULL != (j = cJSON_CreateObject())) {
      if (NULL != x->indication_header_format) {
        cJSON_AddItemToObject(j, "indicationHeaderFormat", cJSON_Createindication_header_format(x->indication_header_format));
      }
    }
  }
  return j;
}

char * cJSON_Printric_indication_header(const ric_indication_header_json_t * x) {
  char * s = NULL;
  if (NULL != x) {
    cJSON * j = cJSON_Createric_indication_header(x);
    if (NULL != j) {
      s = cJSON_Print(j);
      cJSON_Delete(j);
    }
  }
  return s;
}

void cJSON_Deleteric_indication_header(ric_indication_header_json_t * x) {
  if (NULL != x) {
    if (NULL != x->indication_header_format) {
      cJSON_Deleteindication_header_format(x->indication_header_format);
    }
    cJSON_free(x);
  }
}

#ifdef __cplusplus
}
#endif

#endif /* __STDOUT__ */
